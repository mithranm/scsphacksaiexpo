#!/usr/bin/env python3
import json
import math
import pathlib
import xml.etree.ElementTree as ET

ROTOR_JOINT_DAMPING = 1e-5

# Test mode default parameters (can be overridden in SDF if plugin supports it)
# These are added to the <plugin> tag in the SDF generated by this script
DEFAULT_PLUGIN_RUN_TEST_MODE = "true" # Set to "false" to disable auto-circle flight
DEFAULT_PLUGIN_TEST_RADIUS = "2.0"
DEFAULT_PLUGIN_TEST_ANGULAR_VELOCITY = "0.5"
DEFAULT_PLUGIN_TEST_ALTITUDE = "1.0"


def box_I(m, x, y, z):
    ixx = m * (y * y + z * z) / 12
    iyy = m * (x * x + z * z) / 12
    izz = m * (x * x + y * y) / 12
    return ixx, iyy, izz

def cyl_I(m, r, cyl_length):
    izz = 0.5 * m * r * r
    ixx = iyy = m * (3 * r * r + cyl_length * cyl_length) / 12
    return ixx, iyy, izz

def v3(vec):
    return " ".join(f"{v:.6f}" for v in vec)

def add_inertial(parent, m, inertia_values):
    inert = ET.SubElement(parent, "inertial")
    ET.SubElement(inert, "mass").text = f"{m:.6f}"
    iner = ET.SubElement(inert, "inertia")
    ET.SubElement(iner, "ixx").text = f"{inertia_values[0]:.8e}"
    ET.SubElement(iner, "iyy").text = f"{inertia_values[1]:.8e}"
    ET.SubElement(iner, "izz").text = f"{inertia_values[2]:.8e}"
    for tag in ("ixy", "ixz", "iyz"): ET.SubElement(iner, tag).text = "0"

def add_box_geo(parent, size, name_stub):
    col = ET.SubElement(parent, "collision", name=f"{name_stub}_col")
    vis = ET.SubElement(parent, "visual", name=f"{name_stub}_vis")
    for elem in (col, vis):
        geom = ET.SubElement(elem, "geometry")
        box_el = ET.SubElement(geom, "box")
        ET.SubElement(box_el, "size").text = v3(size)
    if vis.find('material') is None:
        mat = ET.SubElement(vis, "material")
        script_el = ET.SubElement(mat, "script") # Renamed variable to avoid conflict
        ET.SubElement(script_el, "uri").text = "file://media/materials/scripts/gazebo.material"
        ET.SubElement(script_el, "name").text = "Gazebo/Grey"

def add_cyl_geo(parent, radius, length_val, name_stub):
    col = ET.SubElement(parent, "collision", name=f"{name_stub}_col")
    vis = ET.SubElement(parent, "visual", name=f"{name_stub}_vis")
    for elem in (col, vis):
        geom = ET.SubElement(elem, "geometry")
        cyl = ET.SubElement(geom, "cylinder")
        ET.SubElement(cyl, "radius").text = f"{radius:.6f}"
        ET.SubElement(cyl, "length").text = f"{length_val:.6f}"
    if vis.find('material') is None:
        mat = ET.SubElement(vis, "material")
        script_el = ET.SubElement(mat, "script") # Renamed variable
        ET.SubElement(script_el, "uri").text = "file://media/materials/scripts/gazebo.material"
        ET.SubElement(script_el, "name").text = "Gazebo/DarkGrey"

def add_revolute_joint(model_root, name, parent_link_name, child_link_name, pose_str="0 0 0 0 0 0", axis_xyz="0 0 1"):
    joint = ET.SubElement(model_root, "joint", name=name, type="revolute")
    ET.SubElement(joint, "pose", relative_to=parent_link_name).text = pose_str
    ET.SubElement(joint, "parent").text = parent_link_name
    ET.SubElement(joint, "child").text = child_link_name
    axis = ET.SubElement(joint, "axis")
    ET.SubElement(axis, "xyz").text = axis_xyz
    limit_el = ET.SubElement(axis, "limit")
    ET.SubElement(limit_el, "lower").text = "-1.79769e+308"
    ET.SubElement(limit_el, "upper").text = "1.79769e+308"
    dyn = ET.SubElement(axis, "dynamics")
    ET.SubElement(dyn, "damping").text = f"{ROTOR_JOINT_DAMPING:.2e}"
    return joint

def main():
    MODEL_NAME_FOR_URI_AND_SDF = "tesseract_nano"

    print(f"Generating '{MODEL_NAME_FOR_URI_AND_SDF}' SDF and config...")
    with open("drone_params.json") as f:
        P = json.load(f)

    hx, hy, hz = P["hull"]["length"], P["hull"]["width"], P["hull"]["height"]
    h_mass = P["hull"]["mass"]
    h_inertia = box_I(h_mass, hx, hy, hz)

    L_beam = P["arms"]["length"]
    arm_w, arm_h = P["arms"]["cross_section"]
    arm_mass = L_beam * arm_w * arm_h * P["arms"]["density"]
    arm_inertia = box_I(arm_mass, L_beam, arm_w, arm_h)

    prop_r = P["rotors"]["prop_diameter"] / 2
    rotor_visual_length = 0.005
    rotor_visual_radius = prop_r
    rotor_link_mass = P["rotors"]["motor_mass"] + P["rotors"]["prop_mass"]
    rotor_link_inertia = cyl_I(rotor_link_mass, rotor_visual_radius, rotor_visual_length)

    sdf = ET.Element("sdf", version="1.7")
    model = ET.SubElement(sdf, "model", name=MODEL_NAME_FOR_URI_AND_SDF)
    ET.SubElement(model, "static").text = "false"

    hull_link = ET.SubElement(model, "link", name="hull")
    ET.SubElement(hull_link, "pose").text = f"0 0 {hz / 2:.5f} 0 0 0"
    add_inertial(hull_link, h_mass, h_inertia)
    add_box_geo(hull_link, (hx, hy, hz), "hull_geom")

    arm_angles_radians = [0, math.pi / 2, math.pi, 3 * math.pi / 2] # Front, Right, Rear, Left for '+'

    for i in range(P["arms"]["count"]):
        yaw_rad = arm_angles_radians[i]

        attach_offset_from_hull_center = hx/2
        if i == 1 or i == 3: # Right/Left arms use hy/2 for a rectangular hull
             attach_offset_from_hull_center = hy/2

        arm_com_x = (attach_offset_from_hull_center + L_beam/2) * math.cos(yaw_rad)
        arm_com_y = (attach_offset_from_hull_center + L_beam/2) * math.sin(yaw_rad)
        arm_com_z = hz / 2

        arm_link_name = f"arm_{i}"
        arm_link = ET.SubElement(model, "link", name=arm_link_name)
        ET.SubElement(arm_link, "pose").text = f"{arm_com_x:.5f} {arm_com_y:.5f} {arm_com_z:.5f} 0 0 {yaw_rad:.5f}"
        add_inertial(arm_link, arm_mass, arm_inertia)
        add_box_geo(arm_link, (L_beam, arm_w, arm_h), f"arm_{i}_geom")

        fixed_joint = ET.SubElement(model, "joint", name=f"arm_{i}_fixed_joint", type="fixed")
        ET.SubElement(fixed_joint, "parent").text = "hull"
        ET.SubElement(fixed_joint, "child").text = arm_link_name
        # Pose of fixed joint frame relative to parent (hull) frame
        # This positions the joint origin at the attachment point on the hull surface, aligned with arm.
        joint_px = attach_offset_from_hull_center * math.cos(yaw_rad)
        joint_py = attach_offset_from_hull_center * math.sin(yaw_rad)
        ET.SubElement(fixed_joint, "pose").text = f"{joint_px:.5f} {joint_py:.5f} 0 0 0 {yaw_rad:.5f}" # Joint also yawed

        rotor_link_name = f"rotor_{i}"
        rotor_pos_x = (attach_offset_from_hull_center + L_beam) * math.cos(yaw_rad)
        rotor_pos_y = (attach_offset_from_hull_center + L_beam) * math.sin(yaw_rad)
        rotor_pos_z = hz / 2

        rotor_link = ET.SubElement(model, "link", name=rotor_link_name)
        ET.SubElement(rotor_link, "pose").text = f"{rotor_pos_x:.5f} {rotor_pos_y:.5f} {rotor_pos_z:.5f} 0 0 {yaw_rad:.5f}"
        add_inertial(rotor_link, rotor_link_mass, rotor_link_inertia)
        add_cyl_geo(rotor_link, rotor_visual_radius, rotor_visual_length, f"rotor_{i}_geom")

        # Revolute Joint: Arm to Rotor. Joint is at the tip of the arm.
        # Pose of joint is L_beam/2 along parent arm's X axis.
        joint_pose_in_arm_frame_str = f"{L_beam/2:.5f} 0 0 0 0 0"
        add_revolute_joint(model, f"rotor_{i}_revolute_joint", arm_link_name, rotor_link_name,
                           pose_str=joint_pose_in_arm_frame_str, axis_xyz="0 0 1")

    # --- THIS IS THE CORRECTED LINE ---
    plugin_el = ET.SubElement(model, "plugin", name="trick_executor_plugin", filename="libtrick_executor_plugin.so")
    # --- END OF CORRECTION ---
    ET.SubElement(plugin_el, "zmq_port").text = "5555"
    ET.SubElement(plugin_el, "run_test_mode").text = DEFAULT_PLUGIN_RUN_TEST_MODE
    ET.SubElement(plugin_el, "test_mode_radius").text = DEFAULT_PLUGIN_TEST_RADIUS
    ET.SubElement(plugin_el, "test_mode_angular_velocity").text = DEFAULT_PLUGIN_TEST_ANGULAR_VELOCITY
    ET.SubElement(plugin_el, "test_mode_altitude").text = DEFAULT_PLUGIN_TEST_ALTITUDE

    ws_model_dir_base = pathlib.Path.cwd() / ".gazebo/models"
    ws_model_dir = ws_model_dir_base / MODEL_NAME_FOR_URI_AND_SDF
    ws_model_dir.mkdir(parents=True, exist_ok=True)

    if hasattr(ET, "indent"): ET.indent(sdf)
    tree = ET.ElementTree(sdf)
    sdf_file_path = ws_model_dir / "model.sdf"
    tree.write(sdf_file_path, xml_declaration=True, encoding="UTF-8", short_empty_elements=True)

    (ws_model_dir / "model.config").write_text(
f"""<?xml version="1.0"?>
<model>
  <name>{MODEL_NAME_FOR_URI_AND_SDF}</name>
  <version>1.0</version>
  <sdf version="1.7">model.sdf</sdf>
  <author><name>Parametric Script</name><email>your@email.com</email></author>
  <description>Tesseract Nano drone base model for Gazebo with test mode params.</description>
</model>
""")
    print(f"âœ“  Wrote model to {ws_model_dir}")

if __name__ == "__main__":
    main()